<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dynamic Voronoi Diagram</title>
  </head>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }

    canvas {
      border-radius: 5px;
    }
  </style>
  <body>
    <canvas id="voronoiCanvas" width="600" height="600"></canvas>
  </body>
  <script>
    let colorPalette = {
      "Spring Cream": "#EFF1E4",
      "Green Tea Pudding": "#C5E1A5",
      // "Le Bon Dijon": "#E4CB6B",
      "Fake Fern": "#529875",
      "Shadow Pine": "#356454",
      "Lacquer Green": "#1B322C",
    };

    let movingPoint = { x: 300, y: 200, color: "#E4CB6B" }; // Initial position of the moving point
    let speed = 5; // Speed of the moving point
    let angle = Math.random() * Math.PI * 2;

    function updateMovingPoint() {
      // Randomly update direction - for simplicity
      speed += (Math.random() - 0.25) * 0.25;
      angle += (Math.random() - 0.25) * 0.25;

      movingPoint.x += Math.cos(angle) * speed;
      movingPoint.y += Math.sin(angle) * speed;

      // Keep the moving point within canvas bounds of 600 x 600, using modulo
      movingPoint.x = (movingPoint.x + 600) % 600;
      movingPoint.y = (movingPoint.y + 600) % 600;
    }

    const canvas = document.getElementById("voronoiCanvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const numPoints = 30;
    const points = [];

    // Generate random seed points
    for (let i = 0; i < numPoints; i++) {
      points.push({
        x: Math.random() * width,
        y: Math.random() * height,
        color:
          Object.values(colorPalette)[
            Math.floor(Math.random() * Object.values(colorPalette).length)
          ],
        // `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(
        //   Math.random() * 256
        // )}, ${Math.floor(Math.random() * 256)})`,
      });
    }

    function distance(x1, y1, x2, y2) {
      return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    }

    function drawVoronoi() {
      ctx.clearRect(0, 0, width, height); // Clear the canvas

      for (let x = 0; x < width; x++) {
        for (let y = 0; y < height; y++) {
          let closestPoint = points[0];
          let minDist = distance(x, y, points[0].x, points[0].y);

          // Include moving point in distance calculation
          points.push(movingPoint);

          for (let i = 1; i <= numPoints; i++) {
            const d = distance(x, y, points[i].x, points[i].y);
            if (d < minDist) {
              closestPoint = points[i];
              minDist = d;
            }
          }

          // Remove moving point after calculation
          points.pop();

          ctx.fillStyle = closestPoint.color;
          ctx.fillRect(x, y, 1, 1);
        }
      }
    }

    // Update and redraw loop
    function animate() {
      updateMovingPoint(); // Update the position of the moving point
      drawVoronoi(); // Redraw the Voronoi diagram
      requestAnimationFrame(animate); // Repeat
    }

    animate();
  </script>
</html>
